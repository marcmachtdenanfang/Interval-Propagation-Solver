<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interval Propagation Solver – Dokumentation</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
    <meta name="color-scheme" content="dark light">
  </head>
<body>
<h1>Interval Propagation Solver</h1>


<h2 id="einleitung">Einleitung</h2>
<p>Implementierung von <a href="https://github.com/Clon451">Clon451</a> und <a href="https://github.com/marcmachtdenanfang">marcmachtdenanfang</a> basierend auf <a href="http://hs.informatik.uni-oldenburg.de/tino/papers/FraenzleEtAl_JSAT07.pdf" target="blank">Efficient Solving of Large Non-Linear Arithmetic Constraint Systems with Complex Boolean Structure</a> (2007) von Martin Fränzle, Christian Herde, Tino Teige, Stefan Ratschan, Tobias Schubert.

  <br>
  In der Implementierung dieses Softwareprojektes haben wir uns sehr nah an die Formalisierung des Papers gehalten. Einige unserer Klassen sind eins zu eins den Erklärungen im Paper nachempfunden. Das Prinzip ist es, mithilfe von Intervallpropagierung und integriertem DPLL-Mechanismus, Lösungen für eine boolsche Kombination von arithmetischen Formeln zu finden.
  In Abschnitt 4.2 des Papers wird die Logik des Verfahrens beschrieben. Diese haben wir nachgebaut. In Abschnitt 4.3 werden Erweiterungen vorgestellt, die wir nicht eingebaut haben.

  <br><br>
  Unsere Software besteht aus den folgenden Kernbestandteilen:
  <dl>
    <dt><a href="#parser">Parser</a></dt>
    <dd>Modul, das die Eingabe <u>parst</u>.</dd>
    <dt><a href="#app">App</a></dt>
    <dd>Modul, das die <u>Ausführung</u> erlaubt.</dd>
    <dt><a href="#context">Context</a></dt>
    <dd>Modul, das den <u>Kontrollfluss</u> und den Kern der <u>Logik</u> darstellt.</dd>
    <dt><a href="#model">Model</a></dt>
    <dd>Module, zur Verwaltung der <u>Datentypen</u> die im Paper beschrieben werden.</dd>
    <dt><a href="#contractors">Contractors</a></dt>
    <dd>Modul, das die Umsetzung der <u>Intervallpropagierung</u> darstellt.</dd>
  </dl>

  <br>//Einschränkungen, Unterschiede, genereller Überblick...</p>


<h2 id="parser">Parser</h2>
<p>Unser Parser ist zuständig für das Lesen der Eingabedatei und die Umformung in Klassen und Datentypen die unser Solver verwendet. Als Eingabeformat wurde sich stark an HySAT gehalten (siehe den <a href=" https://uol.de/f/2/dept/informatik/ag/hs/hysat/user_guide/hysat-user-guide.pdf" target="blank">HySAT Quick Start Guide</a>), größter Unterschied ist allerdings, dass Konstanten immer explizit vom Typ <code>float</code> oder <code>int</code> sein müssen. Zahlen ohne Dezimalpunkt sind immer <code>int</code>, mit Dezimalpunkt ergibt sich <code>float</code>. Für weniger Probleme beim Parsen ersetzt außerdem der arithmetische Operator <code>neg(<i>variable</i>)</code> das Symbol <code>-</code> als unäres Minus, so muss jenes nur noch für Subtraktionen und negative Zahlen verwendet werden. Zusätzlich wird <code>/</code> für Divisionen unterstützt. Da wir nur Funktionen in konjunktiver Normalform betrachten sind zudem die Operationen <code>nand</code>, <code>nor</code>, <code>xor</code>, <code>nxor</code> und <code>impl</code> unnötig. Alles restliche entspricht dem Single-Formula-Mode aus HySAT.</p>

<h3 id="init0">init</h3>
<p>Der erste Konstruktorblock der <code>Parser</code>-Klasse nimmt <code>filePath</code> als Beschreibungsstring des Eingabedateipfads entgegen. Jene Datei wird Zeile für Zeile abgearbeitet, wobei Kommentare, Einrückungen und das Semikolon-Suffix entfernt werden. Über die Schlagwörter <code>"DECL"</code> und <code>"EXPR"</code> wird zwischen Zeilen mit Deklaration und der eigentlichen Formel unterschieden und für <code>declarations.declare()</code> und <code>expressions.express()</code> in jeweils entsprechenden Listen abgelegt.</p>

<h3 id="declare">declare</h3>
<p>Bei <code>MutableList&lt;String&gt;.declare()</code> wird jede Deklarationseingabezeile durchgegangen. Handelt es sich um eine Konstantendefinition, wird sie in den <code>constants</code> gespeichert. Booleans werden als Variablen von 0 bis 1 abgelegt. Ansonsten werden Variablen mit ihrem jeweiligen Intervall (mithilfe von <code>boundVariables()</code>) in <code>variables</code> gespeichert.</p>

<h3 id="express">express</h3>
<p>Bei <code>MutableList&lt;String&gt;.express()</code> wird zunächst jede Formeleingabezeile als <code>expr</code> durchgegangen. Gibt es Klammern in <code>expr</code>, wird solange das erste Paar innerster Klammern über <code>innerBrackets()</code> gefunden und auf diverse Arten entfernt, bis es keine mehr gibt. Hierbei muss unterschieden werden, ob die Klammern zu einer Operation gehören und so wird zur <code>expressions</code>-Liste ein neuer String <code>".<span>braOp</span>°<span>inner</span>"</code> hinzugefügt, wobei statt <code>braOp</code> die entsprechende Operation (entweder <code>neg</code>, <code>abs</code>, <code>exp</code>, <code>sin</code>, <code>cos</code>, <code>min</code>, <code>max</code>, <code>pow</code>, <code>nrt</code>) und statt <code>inner</code> das innere der Klammer geschrieben wird. Zudem wird das Vorkommen von <code>"<span>braOp</span>(<span>inner</span>)"</code> in <code>expr</code> durch <code>"_<span>braOp</span><span>idx</span>"</code> ersetzt, wobei <code>idx</code> für einen neuen Index des jeweiligen Operationstyps steht. Ansonsten dienen Klammern der Klammerung. In Verbindung mit Konjunktion und Disjunktion können sie ignoriert werden, da wir nur Funktionen in konjunktiver Normalform betrachten und Klauseln entsprechend gruppieren. Nur wenn sie also in Formeln auftreten, verändern sie die Präzedenz und wir fügen zur <code>expressions</code>-Liste einen neuen String <code>".bra°<span>inner</span>"</code> hinzu, wobei wieder statt <code>inner</code> das innere der Klammer geschrieben wird und <code>"(<span>inner</span>)"</code> bei <code>expr</code> zu <code>"_bra<span>bracketCount</span>"</code> wird (<code>bracketCount</code> erhöht sich für jede dieser Klammerungen).</p>
<p>Nach den Klammern wird das Minussymbol von Subtraktionen durch eine Tilde und das logische <code>not</code> durch das alternative Ausrufezeichen ausgetauscht. Die <code>addAllFrom</code>-Funktion wird nun rekursive auf <code>powers</code>, <code>multiplications</code>, <code>divisions</code>, <code>additions</code> und <code>subtractions</code> aufgerufen und speichert die Operationsparameter unter den jeweiligen <code>BinaryOperations</code>, während es die (diesmal mit <code>"_<span>opName</span><span>size</span>"</code>) veränderte <code>expr</code> zurückgibt. Die <code>bound</code>-Funktion macht schließlich etwas ähnliches für die Relationen <code>>=</code>, <code><=</code>, <code>!=</code>, <code>=</code>, <code>></code> und <code><</code>, nur wird alles in einer <code>boundList</code> abgespeichert und der Relationstyp explizit als String mit hineingenommen. Als letztes sorgt <code>cleanUp(expr)</code> dafür, dass alle übrigen Literale korrekt in <code>clauseList</code> eingetragen werden. Es sein denn jenes sind Einträge, die bei der Klammerabarbeitung an <code>expressions</code> angefügt wurden. Sie werden stattdessen in ihren entsprechenden <code>UnaryOperations</code> oder <code>BinaryOperations</code> gespeichert.</p>

<h3 id="init1">init</h3>
<p>Der zweite Block der Initialisierung nimmt nun die Zwischendarstellung – die sonst hauptsächlich für eine String-Darstellung der Formel über <code>toString()</code> und <code>asCNF()</code> dient – und füllt damit ein Objekt der Java-Klasse <code>Formula</code>, sowie <code>intervals</code> als <code>MutableMap&lt;String, Interval&gt;</code>. Dazu wird für Konstanten ein entsprechendes <code>DotInterval</code> und für Variablen ein <code>Interval</code> erstellt. Pro <code>boundList</code>-Eintrag wird eine äquivalente <code>Bound</code> angelegt, wobei darauf geachtet wird, dass Konstanten nur rechts vom Relationssymbol stehen dürfen, ansonsten wird die Relationen einfach gespiegelt. Die <code>clauseList</code> wird danach abgearbeitet. Dort werden die temporären Variablen, die für Klammern und Relationen verwendet wurden aufgelöst und Literale mit positiver oder negativer Polarität zu Klauseln zusammengefügt. Da der Inhalt von Operationen in den separaten <code>BinaryOperations</code> und <code>UnaryOperations</code> liegt, tragen die <code>operateBi</code>- und <code>operateUn</code>-Funktionen entsprechend notwendige Klauseln für die <code>Formula</code> und Intervalle in <code>intervals</code> zusammen. Die <code>getIntervals</code>-Funktion legt dafür bei Bedarf bisher noch nicht benötigte Intervalle für den passenden Variablennamen initial an. In der Formel auftretende Zahlen werden als <code>DotInterval</code> gelesen, aber nicht extra in <code>intervals</code> gespeichert. Zuletzt findet <code>typecasting()</code> statt. Da gemischte Formeln mit <code>int</code> und <code>float</code> erlaubt sind (sofern sie nicht im selben Literal auftreten) und die vorherige Funktion nicht immer direkt den Formeltyp erkennt, ist dieser Schritt nötig. Ist so der Typ eines <code>Interval</code> zu den eigens angelegten Variablen <code>null</code>, weil <code>constraints</code> in ungünstiger Reihenfolge auf Variablen anderer <code>constraints</code> verweisen, wird anhand der anderem im <code>constraint</code> vorkommenden Variablen der Typ ausgemacht. Jener wird immer gefunden, da Problemvariablen einen bekannten Typen besitzen.</p>


<h2 id="app">App</h2>
<p>Die <code>App</code>-Klasse enthält unsere <code>main</code>-Funktion, die zum Aufruf des Programms verwendet wird.

<h3 id="execution">Kompilierung & Ausführung</h3>
Wir verwenden das Tool <code>Maven</code> zur Kompilierung und Verwaltung der Softwarekomponenten. Eine Installation von <code>Maven</code> ist daher notwendig. Zur Ausführung wird eine Installation der Java VM (getestet mit Version 11) benötigt.
<pre><code>
  mvn package # Kompilierung mithilfe von Maven
  java -cp target/Interval-Propagation-Solver-0.1-ALPHA-jar-with-dependencies.jar org.mcnip.solver.App # Ausführung
</code></pre>

Unser Programm erlaubt die Spezifizierung von Optionen vor Aufruf des Programms. Folgende Optionen existieren
<dl>
  <dt>-h, --help</dt>
  <dd>Aufruf der folgenden Optionen und sofortige Terminierung des Programms.</dd>
  <dt>-i,--input &ltarg&gt </dt>
  <dd>arg ist der Pfad zur Eingabedatei. Diese Option <u>muss</u> vom Nutzer angegeben werden.</dd>
  <dt>-p,--print</dt>
  <dd>Ausgabe der geparsten Formel in konjunktiver Normalform.</dd>
  <dt>-v,--verbose</dt>
  <dd>Ausgabe der <code>assertedAtoms</code> und der aktuellen Intervallgrenzen unter den <code>assertedAtoms</code> zu jeder Iteration. Außerdem Ausgabe der Ergebnisse der vom Parser generierten Variablen.</dd>
  <dt>-l,--likelihood &ltarg&gt</dt>
  <dd>Änderung der Wahrscheinlichkeit für Variablensplitting (siehe unten, <a href=#splitvariableinterval><code>splitVariableInterval</code></a>).</dd>
  <dt>-m,--minimize &ltarg&gt</dt>
  <dd>Minimierung einer bestimmten Variable der Eingabeformel.</dd>
  <dt>-b,--intPrecision &ltarg&gt</dt>
  <dd>Änderung der Bitbreite der Integer Variablen (siehe <a href=#splitvariableinterval><code>splitVariableInterval</code></a> und <a href=#IPSNumber><code>IPSNumber</code></a>). Der Standard ist 128 bit.</dd>
</dl>

Ein kompletter Aufruf sähe also zum Beispiel so aus:
<pre>
  <code>
    java -cp target/Interval-Propagation-Solver-0.1-ALPHA-jar-with-dependencies.jar org.mcnip.solver.App -i hys-formulas/ex1.hys -p

  </code>
</pre>

<br>Mit hilfe der Aufrufparameter wird eine Instanz <code>ctx</code> der <code><a href="#context">Context-Klasse</a></code> initialisiert. Auf <code>ctx</code> wird die Methode <code>solve()</code> aufgerufen. Bei einer erfüllbaren Formel ergibt sich hier die Ausgabe <code>"SAT"</code>, sowie die Werte der Variablen. Andernfalls wird <code>"UNSAT"</code> ausgegeben. Die App-Klasse enthält somit nur die Funktionalität zur Ausführung des Programms, die Logik befindet sich in der <code><a href="#context">Context-Klasse</a></code> und den weiteren Unterklassen.</p>


<h2 id="context">Context</h2>
<p>Die <code>Context</code>-Klasse ist für den Zustand unseres Solvers verantwortlich und bildet dessen Kernfunktionalität. Die <code>formula</code> erhält der Kontext vom Parser und aus seinen Intervallgrenzen <code>intervals</code> wird die erste Schicht des <code>intervalAssignmentStack</code>s. Der <code>intervalAssignmentStack</code> entspricht Σ aus dem Paper und die Stapelelemente speichern alle Intervallgrenzen unter den aktuell <code>assertedAtoms</code>. Die <code>assertedAtoms</code> sind mit <code>Marker</code>-Elementen getrennt, um Schichten (jede ist eine weitere Verzweigungstiefe) abzugrenzen. Da beim Parser auch schon direkt die Hilfsvariablen gesetzt wurden, ist Schritt 1 aus Abschnitt 4.2 des Papers schon abgeschlossen nach dem Aufruf des Konstruktors.</p>

<h3 id="solve">solve</h3>
<p>Die Organisation der verbleibenden Schritte wird von <code>solve()</code> übernommen. Es wird dabei darauf geachtet, ob unsere Formel mit den aktuellen Intervallgrenzen erfüllbar ist. Zunächst wird <code>assertUnitClauses()</code> gestartet (Schritt 2 im Paper). Tritt hierbei ein Konflikt auf, der zur Unerfüllbarkeit führen würde, wird eine vorherige Verzweigungsentscheidung über <code>revertPreviousSplit()</code> (Schritt 5) rückgängig gemacht. Falls es keine vorherige Verzweigung gibt, wird <code>false</code> zurückgegeben ansonsten beginnt die Schleife wieder bei <code>assertUnitClauses()</code>. Funktioniert diesmal alles konfliktfrei, wird mit <code>narrowContractions()</code> Schritt 3 durchgeführt. Tritt nun ein Konflikt auf, wird ebenfalls <code>revertPreviousSplit()</code>, ansonsten <code>splitVariableInterval()</code> (Schritt 4) durchgeführt. Ist bei letzterer Funktion keine Variable mehr übrig, haben wir ein gültiges Ergebnis gefunden und enden mit <code>true</code>.</p>

<h3 id="assertunitclauses">assertUnitClauses</h3>
<p>Bei <code>assertUnitClauses()</code> wird das meiste in die <code>findUnits</code>-Kotlinfunktion ausgelagert. Die <code>clauses</code> der Formel werden durchgegangen und für alle Literale (<code>constraints</code>) wird die <code>updateIntervals</code>-Funktion (entspricht update<sub>ρ</sub> im Paper) durchgeführt. Alle erhaltenen Unit-Klauseln werden letztlich zurückgegeben, außer es trat die leere Menge auf, dann geht <code>null</code> an <code>assertUnitClauses()</code>, um schnell Unerfüllbarkeit im aktuellen Zustand zu signalisieren. Dort werden ansonsten die neuen Unit-Klauseln zu den <code>assertedAtoms</code> hinzugefügt.</p>

<h3 id="narrowcontractions">narrowContractions</h3>
<p>Bei <code>narrowContractions()</code> werden zuallererst die Atome aus <code>assertedAtoms</code> extrahiert, die zuletzt zu den <code>assertedAtoms</code> hinzugefügt wurden (also bis ein <code>Marker</code> erreicht wird). 
<br>Der Kern von Schritt 3 wird in der <code>narrowContractors</code>-Kotlinfunktion angegangen. Die gerade extrahierten <code>Atome</code> werden unter dem <code>currentAssignment</code> der Intervalle genutzt, um die Intervalle der sie betreffenden Variablen zu verfeinern (<code>Atom.update</code>-Funktion). Dazu wird die <code>updateIntervals</code>-Funktion mit den zu den Variablen gehörenden Intervallen aufgerufen, jeweils abhängig davon, ob das Atom eine <code>Bound</code>, ein <code>Pair</code> (in Kotlin als <code>Dyad</code> importiert, um nicht in Namenskonflikt mit <code>kotlin.Pair</code> zu stehen) oder <code>Triplet</code> ist. Ergibt sich ein leeres Intervall, kann wieder frühzeitig abgebrochen werden und <code>null</code> zurückgegeben werden. Ansonsten erhält <code>currentAssignment</code> die neuen Intervallgrenzen und bei Pair und Triplets wird von Intervallgrenzen eine Liste von <code>Bound</code>s (jene zu den <code>assertedAtoms</code> zu nehmen, wie im Paper geschrieben, hatte in unseren Tests immer die Performance verschlechtert, weshalb wir darauf verzichten). Zurück in der Oberfunktion wird das oberste <code>intervalAssignmentStack</code>-Element aktualisiert. Erneut wird die <code>findUnits</code>-Funktion aufgerufen, diesmal ist das nur mit den <code>lastAssertedAtoms</code> notwendig. Findet Unit-Propagation keine neuen Atome, ist Schritt 3 beendet, andernfalls wird ein neuer Schleifendurchlauf begonnen.</p>

<h3 id="splitvariableinterval">splitVariableInterval</h3>
<p>In der Methode <code>splitVariableInterval()</code> wird Schritt vier des Papers implementiert. Hierbei soll eine Variable gefunden werden, die gesplittet wird, mit dem Ziel einen neuen Bound zu finden. Falls dieser sich letzten Endes als schlecht herausstellt, so wird diese Entscheidung in <code><a href="revertprevioussplit">revertPreviousSplit()</a></code> zurückgennomen. <br>Es werden die Problemvariablen aus der obersten Menge der <code>intervalAssignments</code> des <code>intervalAssignmentStacks</code> extrahiert (zur Erinnerung: Problemvariablen sind diejenigen Variablen, die in der Eingabeformel spezifiziert sind). Dabei werden nur Variablen gefunden, deren Intervall größer als ein Element ist (sonst könnte man sie nicht splitten).
Wenn es keine Problemvariablen gibt, deren Intervall größer als ein Element ist, dann werden auch die generierten Variablen überprüft. Mit einer <code>1:N</code> Wahrscheinlichkeit werden immer die generierten Variablen mitgefiltert. Standardmäßig ist N auf fünf gesetzt.
Außerdem haben wir, wie in <a href="execution">Ausführung</a> bereits erwähnt, die Möglichkeit eingebaut, N zu verändern.
Aus dieser Menge an Variablen wird zufällig eine Variable gewählt, die gesplittet wird. Daraus wird ein <code>Bound</code> generiert, der auf den Stapel der <code>assertedAtoms</code> gelegt wird. Da dies ein sogenannter Backtrackingpunkt (siehe <a href="revertprevioussplit">revertPreviousSplit</a>) ist, wird vorher noch ein <code>Marker</code> auf den Stapel gelegt.

Die Zufälligkeit der Wahl der Variable, die wir splitten, sowie die Zufälligkeit ob wir generierte Variablen splitten, ist die einzige Heuristik, die wir erprobt haben. Diese kann ganz gut funktionieren in einzelnen Benchmarks aber auch zu längeren Ausführungszeiten führen.

</p>

<h3 id="revertprevioussplit">revertPreviousSplit</h3>
<p>Bei <code>revertPreviousSplit()</code> wird der fünfte und letzte Schritt umgesetzt. Das oberste Element des <code>intervalAssignmentStack</code> kann zunächst verworfen werden. Dann werden die <code>assertedAtoms</code>  Stück für Stück entstapelt, bis das erste Atom gefunden wurde, welches auf dem obersten <code>Marker</code>-Objekt liegt. Ist der Stapel geleert bevor jenes gefunden wurde, haben wir Unerfüllbarkeit erkannt, was direkt durch die Rückgabe von <code>true</code> signalisiert wird. Andernfalls finden wir das verantwortliche <code>guiltyAtom</code> (immer eine durch <code>splitVariableInterval()</code> gesetzte <code>Bound</code>) und <code>invert()</code>-ieren es (der Relationskontraktor wird invertiert), bevor es bei den <code>assertedAtoms</code> landet. Zuletzt wird wieder die oberste Schicht vom <code>intervalAssignmentStack</code> mit dem veränderten <code>guiltyAtom</code> aktualisiert.</p>


<h2 id="model">Model</h2>
In dem <code>Model</code>-Ordner sind die Klassen, die unsere Modelle ausmachen spezifiziert.
Wir benutzen einiges an Polymorphie um unseren Code einfacher zu gestalten.

<h3 id="Atom">Atom</h3>
Wir haben das <code>Atom</code>-Interface. Dieses wird von <code>Constraint</code> und <code>Marker</code> implementiert. <code>Marker</code> werden nur für die Stapel in der <code>Context</code>-Klasse verwendet. <code>Constraints</code> werden von <code>Pair</code>, <code>Triple</code> und <code>Bound</code> erweitert. <code>Constraints</code> enthalten gezwungenermaßen einen <code>Contractor</code>, der die arithmetische/logische Operation spezifiziert. <code>Pair</code>, <code>Triple</code> und <code>Bound</code> folgen der Definition des Papers. Sie enthalten jeweils die Intervalle, die die Bestandteile der Operation sind. Ein Pair wie <code>x=-y</code> besteht also aus dem <code>Negierungscontractor</code>, und den Intervallen <code>x</code> und <code>y</code>.

<h3 id="intervall">IPSNumber & Interval</h3>
Unsere Basisdatentypen für die Repräsentation von Zahlen und Intervallen sind die <code>IPSNumber</code>- und <code>Interval</code>-Klassen. <code>IPSNumber</code> ist eine Wrapperklasse um sowohl Integer als auch Fließkommazahlen in einem zu verarbeiten. Integer werden mit der <code>BigInteger</code>-Klasse repräsentiert. 
Um symbolische Unendlichkeit bei Integern zu erreichen, wird in den Fließkommazahlwerten der IPSNumber die jeweilige Unendlichkeit gespeichert. <code>IPSNumber</code>s erlauben alle arithmetischen Operationen zwischeneinander. Ob eine <code>IPSNumber</code> als INT oder als REAL geparst wurde, ist im Typen der <code>IPSNumber</code> eingespeichert. 
<code>Interval</code>s enthalten den Namen der Variable, sowie die Intervalgrenzen. Außerdem wird hier die Methode zur Berechnung des Mittelpunkts bereitgestellt.
Durch die Vereinheitlichung des Zahlendatentyps, wird im Allgemeinen die Codekomplexität außerhalb dieser beiden Klassen massiv vereinfacht.

<h3 id="formula">Formula & Clause</h3>
Eine <code>Formula</code> ist eine Liste voller <code>Clause</code>s. Eine <code>Clause</code> ist eine Liste voller Constraints. Beides hilft zur einfacheren Verwaltung unseres Systems.

<h2 id="contractors">Contractors</h2>
Für die <code>Contractor</code>s verwenden wir erneut Polymorphie, um den Code einfacher zu gestalten. Alle <code>Condtractor</code>s implementieren eine arithmetisch/logische Operation. Die konkrete Implementierung erfolgt im Kotlincode. Wir unterscheiden zwischen drei unterschiedlichen Typen an <code>Contractor</code>s:

<dl>
  <dt><code>BinContractors</code></dt>
  <dd>Hier werden die binären Operationen implementiert (Addition, Subtraktion, Multiplikation, Division, Maximum, Minimum, Nte Wurzel und Potenz). Diese <code>Contractor</code>s werden also von <code>Triplets</code> verwendet. Die <code>contract()</code>-Methode erhält eine Hashmap an Intervallen, mit Variablennamen als Schlüssel, sowie ein Array der Namen der Variablen. Die Reihenfolge im Array ist: an Index 0 steht das Resultat, an Index 1 das erste Argument der Operation und an Index 2 das zweite Argument der Operation.</dd>

  <dt><code>UnContractors</code></dt>
  <dd>Hier werden die unären Operationen implementiert (Sinus, Cosinus, Absoluter Wert, "e hoch" bzw. "exp" sowie die Negierung). Die <code>contract()</code>-Methode erhält eine Hashmap an Intervallen, mit Variablennamen als Schlüssel, sowie ein Array der Namen der Variablen. Die Reihenfolge im Array ist: an Index 0 steht das Resultat, an Index 1 das Argument der Operation.</dd>
  <dt><code>BoundContractors</code></dt>
  <dd>Hier werden die Bound Operation implementiert (<code>&lt, &lt=, =, &gt=, &gt</code>).
    Die <code>contract()</code>-Methode erhält eine Hashmap an Intervallen, mit Variablennamen als Schlüssel, sowie ein Array der Namen der Variablen. Die Reihenfolge im Array ist: an Index 0 steht die linke Variable, an Index 1 die rechte Variable. Wichtig zu erwähnen ist: bei Ungleichheiten erlauben wir (dem Paper folgend) lediglich Konstanten.</dd>
</dl>

</body>

</html>