<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interval Propagation Solver – Dokumentation</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
    <meta name="color-scheme" content="dark light">
  </head>
<body>
<h1>Interval Propagation Solver</h1>
<h2 id="einleitung">Einleitung</h2>
<p>Implementierung basierend auf <a href="http://hs.informatik.uni-oldenburg.de/tino/papers/FraenzleEtAl_JSAT07.pdf" target="blank">Efficient Solving of Large Non-Linear Arithmetic Constraint Systems with Complex Boolean Structure</a> (2007) von Martin Fränzle, Christian Herde, Tino Teige, Stefan Ratschan, Tobias Schubert.
<br>//Einschränkungen, Unterschiede, genereller Überblick...</p>
<h2 id="parser">Parser</h2>
<p>Unser Parser ist zuständig für das Lesen der Eingabedatei und die Umformung in Klassen und Datentypen die unser Solver verwendet. Als Eingabeformat wurde sich stark an HySAT gehalten (siehe den <a href=" https://uol.de/f/2/dept/informatik/ag/hs/hysat/user_guide/hysat-user-guide.pdf" target="blank">HySAT Quick Start Guide</a>), größter Unterschied ist allerdings, dass Konstanten immer explizit vom Typ <code>float</code> oder <code>int</code> sein müssen. Zahlen ohne Dezimalpunkt sind immer <code>int</code>, mit Dezimalpunkt ergibt sich <code>float</code>. Für weniger Probleme beim Parsen ersetzt außerdem der arithmetische Operator <code>neg(<i>variable</i>)</code> das Symbol <code>-</code> als unäres Minus, so muss jenes nur noch für Subtraktionen und negative Zahlen verwendet werden. Zusätzlich wird <code>/</code> für Divisionen unterstützt. Da wir nur Funktionen in konjunktiver Normalform betrachten sind zudem die Operationen <code>nand</code>, <code>nor</code>, <code>xor</code>, <code>nxor</code> und <code>impl</code> unnötig. Alles restliche entspricht dem Single-Formula-Mode aus HySAT.
<h3 id="init0">init</h3>
<p>Der erste Konstruktorblock der <code>Parser</code>-Klasse nimmt <code>filePath</code> als Beschreibungsstring des Eingabedateipfads entgegen. Jene Datei wird Zeile für Zeile abgearbeitet, wobei Kommentare, Einrückungen und das Semikolon-Suffix entfernt werden. Über die Schlagwörter <code>"DECL"</code> und <code>"EXPR"</code> wird zwischen Zeilen mit Deklaration und der eigentlichen Formel unterschieden und für <code>declarations.declare()</code> und <code>expressions.express()</code> in jeweils entsprechenden Listen abgelegt.</p>
<h3 id="declare">declare</h3>
<p>Bei <code>MutableList&lt;String&gt;.declare()</code> wird jede Deklarationseingabezeile durchgegangen. Handelt es sich um eine Konstantendefinition, wird sie in den <code>constants</code> gespeichert. Booleans werden als Variablen von 0 bis 1 abgelegt. Ansonsten werden Variablen mit ihrem jeweiligen Intervall (mithilfe von <code>boundVariables()</code>) in <code>variables</code> gespeichert.</p>
<h3 id="express">express</h3>
<p>Bei <code>MutableList&lt;String&gt;.express()</code> wird zunächst jede Formeleingabezeile als <code>expr</code> durchgegangen. Gibt es Klammern in <code>expr</code>, wird solange das erste Paar innerster Klammern über <code>innerBrackets()</code> gefunden und auf diverse Arten entfernt, bis es keine mehr gibt. Hierbei muss unterschieden werden, ob die Klammern zu einer Operation gehören und so wird zur <code>expressions</code>-Liste ein neuer String <code>".<span>braOp</span>°<span>inner</span>"</code> hinzugefügt, wobei statt <code>braOp</code> die entsprechende Operation (entweder <code>neg</code>, <code>abs</code>, <code>exp</code>, <code>sin</code>, <code>cos</code>, <code>min</code>, <code>max</code>, <code>pow</code>, <code>nrt</code>) und statt <code>inner</code> das innere der Klammer geschrieben wird. Zudem wird das Vorkommen von <code>"<span>braOp</span>(<span>inner</span>)"</code> in <code>expr</code> durch <code>"_<span>braOp</span><span>idx</span>"</code> ersetzt, wobei <code>idx</code> für einen neuen Index des jeweiligen Operationstyps steht. Ansonsten dienen Klammern der Klammerung. In Verbindung mit Konjunktion und Disjunktion können sie ignoriert werden, da wir nur Funktionen in konjunktiver Normalform betrachten und Klauseln entsprechend gruppieren. Nur wenn sie also in Formeln auftreten, verändern sie die Präzedenz und wir fügen zur <code>expressions</code>-Liste einen neuen String <code>".bra°<span>inner</span>"</code> hinzu, wobei wieder statt <code>inner</code> das innere der Klammer geschrieben wird und <code>"(<span>inner</span>)"</code> bei <code>expr</code> zu <code>"_bra<span>bracketCount</span>"</code> wird (<code>bracketCount</code> erhöht sich für jede dieser Klammerungen).</p>
<p>Nach den Klammern wird das Minussymbol von Subtraktionen durch eine Tilde und das logische <code>not</code> durch das alternative Ausrufezeichen ausgetauscht. Die <code>addAllFrom</code>-Funktion wird nun rekursive auf <code>powers</code>, <code>multiplications</code>, <code>divisions</code>, <code>additions</code> und <code>subtractions</code> aufgerufen und speichert die Operationsparameter unter den jeweiligen <code>BinaryOperations</code>, während es die (diesmal mit <code>"_<span>opName</span><span>size</span>"</code>) veränderte <code>expr</code> zurückgibt. Die <code>bound</code>-Funktion macht schließlich etwas ähnliches für die Relationen <code>>=</code>, <code><=</code>, <code>!=</code>, <code>=</code>, <code>></code> und <code><</code>, nur wird alles in einer <code>boundList</code> abgespeichert und der Relationstyp explizit als String mit hineingenommen. Als letztes sorgt <code>cleanUp(expr)</code> dafür, dass alle übrigen Literale korrekt in <code>clauseList</code> eingetragen werden. Es sein denn jenes sind Einträge, die bei der Klammerabarbeitung an <code>expressions</code> angefügt wurden. Sie werden stattdessen in ihren entsprechenden <code>UnaryOperations</code> oder <code>BinaryOperations</code> gespeichert.</p>
<h3 id="init1">init</h3>
<p>Der zweite Block der Initialisierung nimmt nun die Zwischendarstellung – die sonst hauptsächlich für eine String-Darstellung der Formel über <code>toString()</code> und <code>asCNF()</code> dient – und füllt damit ein Objekt der Java-Klasse <code>Formula</code>, sowie <code>intervals</code> als <code>MutableMap&lt;String, Interval&gt;</code>. Dazu wird für Konstanten ein entsprechendes <code>DotInterval</code> und für Variablen ein <code>Interval</code> erstellt. Pro <code>boundList</code>-Eintrag wird eine äquivalente <code>Bound</code> angelegt, wobei darauf geachtet wird, dass Konstanten nur rechts vom Relationssymbol stehen dürfen, ansonsten wird die Relationen einfach gespiegelt. Die <code>clauseList</code> wird danach abgearbeitet. Dort werden die temporären Variablen, die für Klammern und Relationen verwendet wurden aufgelöst und Literale mit positiver oder negativer Polarität zu Klauseln zusammengefügt. Da der Inhalt von Operationen in den separaten <code>BinaryOperations</code> und <code>UnaryOperations</code> liegt, tragen die <code>operateBi</code>- und <code>operateUn</code>-Funktionen entsprechend notwendige Klauseln für die <code>Formula</code> und Intervalle in <code>intervals</code> zusammen. Die <code>getIntervals</code>-Funktion legt dafür bei Bedarf bisher noch nicht benötigte Intervalle für den passenden Variablennamen initial an. In der Formel auftretende Zahlen werden als <code>DotInterval</code> gelesen, aber nicht extra in <code>intervals</code> gespeichert. Zuletzt findet <code>typecasting()</code> statt. Da gemischte Formeln mit <code>int</code> und <code>float</code> erlaubt sind (sofern sie nicht im selben Literal auftreten) und die vorherige Funktion nicht immer direkt den Formeltyp erkennt, ist dieser Schritt nötig. Ist so der Typ eines <code>Interval</code> zu den eigens angelegten Variablen <code>null</code>, weil <code>constraints</code> in ungünstiger Reihenfolge auf Variablen anderer <code>constraints</code> verweisen, wird anhand der anderem im <code>constraint</code> vorkommenden Variablen der Typ ausgemacht. Jener wird immer gefunden, da Problemvariablen einen bekannten Typen besitzen.</p>
<h2 id="app">App</h2>
<p>Die <code>App</code>-Klasse enthält unsere <code>main</code>-Funktion. //...
<br>Auf dem Kontext <code>ctx</code> wird <code>solve()</code> ausgerufen. Bei einer erfüllbaren Formel ergibt sich hier die Ausgabe <code>"SAT"</code>, sowie die Werte der Variablen. Andernfalls wird <code>"UNSAT"</code> ausgegeben.</p>
<h2 id="context">Context</h2>
<p>Die <code>Context</code>-Klasse ist für den Zustand unseres Solvers verantwortlich und bildet dessen Kernfunktionalität. Die <code>formula</code> erhält der Kontext vom Parser und aus seinen Intervallgrenzen <code>intervals</code> wird die erste Schicht des <code>intervalAssignmentStack</code>s. Der <code>intervalAssignmentStack</code> entspricht Σ aus dem Paper und die Stapelelemente speichern alle Intervallgrenzen unter den aktuell <code>assertedAtoms</code>. Die <code>assertedAtoms</code> sind mit <code>Marker</code>-Elementen getrennt, um Schichten (jede ist eine weitere Verzweigungstiefe) abzugrenzen. Da beim Parser auch schon direkt die Hilfsvariablen gesetzt wurden, ist Schritt 1 aus Abschnitt 4.2 des Papers schon abgeschlossen nach dem Aufruf des Konstruktors.</p>
<h3 id="solve">solve</h3>
<p>Die Organisation der verbleibenden Schritte wird von <code>solve()</code> übernommen. Es wird dabei darauf geachtet, ob unsere Formel mit den aktuellen Intervallgrenzen erfüllbar ist. Zunächst wird <code>assertUnitClauses()</code> gestartet (Schritt 2 im Paper). Tritt hierbei ein Konflikt auf, der zur Unerfüllbarkeit führen würde, wird eine vorherige Verzweigungsentscheidung über <code>revertPreviousSplit()</code> (Schritt 5) rückgängig gemacht. Falls es keine vorherige Verzweigung gibt, wird <code>false</code> zurückgegeben ansonsten beginnt die Schleife wieder bei <code>assertUnitClauses()</code>. Funktioniert diesmal alles konfliktfrei, wird mit <code>narrowContractions()</code> Schritt 3 durchgeführt. Tritt nun ein Konflikt auf, wird ebenfalls <code>revertPreviousSplit()</code>, ansonsten <code>splitVariableInterval()</code> (Schritt 4) durchgeführt. Ist bei letzterer Funktion keine Variable mehr übrig, haben wir ein gültiges Ergebnis gefunden und enden mit <code>true</code>.</p>
<h3 id="assertunitclauses">assertUnitClauses</h3>
<p>Bei <code>assertUnitClauses()</code> wird das meiste in die <code>findUnits</code>-Kotlinfunktion ausgelagert. Die <code>clauses</code> der Formel werden durchgegangen und für alle Literale (<code>constraints</code>) wird die <code>updateIntervals</code>-Funktion (entspricht update<sub>ρ</sub> im Paper) durchgeführt. Alle erhaltenen Unit-Klauseln werden letztlich zurückgegeben, außer es trat die leere Menge auf, dann geht <code>null</code> an <code>assertUnitClauses()</code>, um schnell Unerfüllbarkeit im aktuellen Zustand zu signalisieren. Dort werden ansonsten die neuen Unit-Klauseln zu den <code>assertedAtoms</code> hinzugefügt.</p>
<h3 id="narrowcontractions">narrowContractions</h3>
<p>Bei <code>narrowContractions()</code> wird //irgendwas gemacht, damit lastAssertedAtoms passt...
<br>Der Kern von Schritt 3 wird in der <code>narrowContractors</code>-Kotlinfunktion angegangen. Die <code>Atom</code>s werden unter dem <code>currentAssignment</code> der Intervalle genutzt, um die Intervalle der sie betreffenden Variablen zu verfeinern (<code>Atom.update</code>-Funktion). Dazu wird die <code>updateIntervals</code>-Funktion mit den zu den Variablen gehörenden Intervallen aufgerufen, jeweils abhängig davon, ob das Atom eine <code>Bound</code>, ein <code>Pair</code> (in Kotlin als <code>Dyad</code> importiert, um nicht in Namenskonflikt mit <code>kotlin.Pair</code> zu stehen) oder <code>Triplet</code> ist. Ergibt sich ein leeres Intervall, kann wieder frühzeitig abgebrochen werden und <code>null</code> zurückgegeben werden. Ansonsten erhält <code>currentAssignment</code> die neuen Intervallgrenzen und bei Pair und Triplets wird von Intervallgrenzen eine Liste von <code>Bound</code>s (jene zu den <code>assertedAtoms</code> zu nehmen, wie im Paper geschrieben, hatte in unseren Tests immer die Performance verschlechtert, weshalb wir darauf verzichten). Zurück in der Oberfunktion wird das oberste <code>intervalAssignmentStack</code>-Element aktualisiert. Erneut wird die <code>findUnits</code>-Funktion aufgerufen, diesmal ist das nur mit den <code>lastAssertedAtoms</code> notwendig. Findet Unit-Propagation keine neuen Atome, ist Schritt 3 beendet, andernfalls wird ein neuer Schleifendurchlauf begonnen.</p>
<h3 id="splitvariableinterval">splitVariableInterval</h3>
<p>//<code>splitVariableInterval()</code></p>
<h3 id="revertprevioussplit">revertPreviousSplit</h3>
<p>Bei <code>revertPreviousSplit()</code> wird der fünfte und letzte Schritt umgesetzt. Das oberste Element des <code>intervalAssignmentStack</code> kann zunächst verworfen werden. Dann werden die <code>assertedAtoms</code>  Stück für Stück entstapelt, bis das erste Atom gefunden wurde, welches auf dem obersten <code>Marker</code>-Objekt liegt. Ist der Stapel geleert bevor jenes gefunden wurde, haben wir Unerfüllbarkeit erkannt, was direkt durch die Rückgabe von <code>true</code> signalisiert wird. Andernfalls finden wir das verantwortliche <code>guiltyAtom</code> (immer eine durch <code>splitVariableInterval()</code> gesetzte <code>Bound</code>) und <code>invert()</code>-ieren es (der Relationskontraktor wird invertiert), bevor es bei den <code>assertedAtoms</code> landet. Zuletzt wird wieder die oberste Schicht vom <code>intervalAssignmentStack</code> mit dem veränderten <code>guiltyAtom</code> aktualisiert.</p>
</body>
</html>